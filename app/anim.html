<!DOCTYPE html>
<html>
<head>
    <!--preventing the user to zoom is not really nice but this is to prevent the browser from zooming when an input is focused-->
    <meta name=viewport content="width=device-width, initial-scale=1, user-scalable=no">
    <title></title>
    <link rel="stylesheet" href="bower_components/reset-css/reset.css" type="text/css">
    <link rel="stylesheet" href="styles/vendor/fontello/fontello.css" type="text/css">
    <link rel="stylesheet" href="styles/css/anim.css" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300,700|Open+Sans+Condensed:300|Oleo+Script+Swash+Caps:400"
          rel="stylesheet" type="text/css">
    <script src="bower_components/angular/angular.js"></script>
    <script src="bower_components/angular-animate/angular-animate.js"></script>
    <script src="bower_components/angular-touch/angular-touch.js"></script>
</head>
<body ng-app="app" ng-controller="mtBodyCtrl" class="activity-state"
      mt-mouse-interaction-detection="mt-mouse-based-interaction">
<div class="mt-debug-bar" ng-show="props.showDebugBar">
    <div class="mt-debug-bar__container">
        <button class="mt-debug-bar__button modal" ng-click="toggleModal(2)">
            Ms
        </button>
        <button class="mt-debug-bar__button modal" ng-click="toggleModal(7)">
            Ml
        </button>
        <button class="mt-debug-bar__button notifications" ng-click="toggleNotification()">
            Ne
        </button>
        <button class="mt-debug-bar__button notifications" ng-click="toggleComingNext()">
            Ncn
        </button>
        <button class="mt-debug-bar__button search" ng-click="toggleSearch()">
            S
        </button>
        <button class="mt-debug-bar__button queue-items" ng-click="appendQueueItem()">
            Ia
        </button>
        <button class="mt-debug-bar__button queue-items" ng-click="insertQueueItem()">
            Ii
        </button>
    </div>
</div>

<div class="mt-app-overlay" ng-show="props.showModal">
    <div class="mt-modal">
        <div class="mt-modal__container">
            <h2 class="mt-modal__title">The title of the modal</h2>

            <div class="mt-modal__content">
                <!-- the following div is the only way I found to fix a rendering problem in Chrome and Safari mobile -->
                <!-- where the hidden part of the overflowing zone is never rendered -->
                <div>
                    <span ng-repeat="i in props.modalLines">Some random content probably very important!
                    <br>Please be careful with that, if you miss it you miss it</span>
                </div>
            </div>

            <div class="mt-modal__commands">
                <button class="mt-modal__button">Confirm</button>
                <button class="mt-modal__button secondary">Cancel</button>
            </div>
        </div>
    </div>
</div>

<div class="video-container" ng-hide="false">
    <div class="video"></div>
</div>

<div class="mt-app">
    <div class="mt-header" mt-search-input>
        <div class="mt-header__bg"></div>
        <div class="mt-header__container">
            <div class="start">
                <h1 class="mt-header__app-title">
                    <span class="logo">M</span><span class="remaining">ixtube</span>
                </h1>
            </div>
            <div class="center">
                <button class="mt-header__play-button" data-mt-icon="&#xe80a">
                    <span class="mt-replaced-text">Play</span>
                </button>
            </div>
            <div class="end">
                <!--just padding container to ensure proper centering of header-center -->
            </div>
        </div>

        <button class="mt-search-input__button mt-js-search-input__button" data-mt-icon="&#xe800">
            <span class="mt-replaced-text">Search</span>
        </button>

        <!-- use form element so that we can intercept submit event triggered by virtual keyboard in mobile browsers -->
        <form class="mt-search-input mt-search-input__animation-toggle mt-js-search-input__form">
            <!-- we could use search input type but we actually don't want the "services" brought by it (cancel button...) -->
            <input ng-model="props.searchTerm" class="mt-search-input__field mt-js-search-input__field"
                   placeholder="Search video" size="30" autocomplete="off" autocorrect="off" autocapitalize="off"
                   spellcheck="false">

            <div class="mt-search-input__fake-field" data-mt-placeholder="Search video"></div>
        </form>
    </div>

    <div class="mt-body">

        <div class="mt-notifications-center">

            <div class="mt-notifications-center__container" ng-if="props.showNotification">
                <div class="mt-notification error">
                    <button class="mt-notification__dismiss-button">&times;</button>
                    <div class="mt-notification__content">
                        <div class="text">
                            Some random content probably very important! Please be careful with that, if you miss it you
                            miss it
                        </div>
                    </div>
                </div>
            </div>

            <div class="mt-notifications-center__container" ng-if="props.showComingNext">
                <div class="mt-notification">
                    <button class="mt-notification__dismiss-button">&times;</button>
                    <div class="mt-notification__content">
                        <div class="thumbnail">
                            <div class="mt-notification__image"
                                 ng-style="{'background-image': 'url(http://i1.ytimg.com/vi/djE-BLrdDDc/mqdefault.jpg)'}"></div>
                        </div>
                        <div class="text">
                            <div class="mt-coming-next__group">
                                <div class="mt-coming-next__header">It was:</div>
                                <div class="mt-coming-next__title">
                                    Kaaris : "J'ai mis 13ans pour faire un Plan√®te Rap, y'a rien
                                    d'exceptionnel !"
                                </div>
                            </div>
                            <div class="mt-coming-next__group next">
                                <div class="mt-coming-next__header">Comming next:</div>
                                <div class="mt-coming-next__title">Ace Hood - Hustle (with lot of details here)</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <div class="mt-queue">
            <ul>
                <li class="mt-queue__item mt-js-queue__item__animation-repeat"
                    ng-class="{'active': $index === 2, 'broken':  $index === 4}"
                    ng-repeat="i in props.queueItems">
                    <div class="mt-queue__item__thumbnail">
                        <div ng-style="{'background-image': 'url(http://i1.ytimg.com/vi/{{i}}/mqdefault.jpg)'}"
                             class="image"></div>
                        <p ng-show="$index === 4" class="mt-queue__item__broken-message">Couldn't load this video</p>

                        <div class="mt-queue__item__progress" ng-show="$index === 1">
                            <progress></progress>
                        </div>
                    </div>
                    <div class="mt-queue__item__data">
                        <p class="mt-queue__item__title">
                            Rick Ros - I like the strawberry Jam a lot
                        </p>

                        <div class="mt-queue__item__commands">
                            <button class="mt-queue__item__remove-button" data-mt-icon="&#xe801" ng-click="dummy()">
                                <span class="mt-replaced-text">Remove</span>
                            </button>
                        </div>
                    </div>
                </li>
            </ul>
        </div>
        <div class="mt-search" ng-show="props.showSearch">
            <div class="mt-search__provider" ng-repeat="pname in ['YouTube', 'Vimeo']">
                <div class="mt-search__provider__header">
                    <h3 class="title">{{pname}}</h3>
                </div>
                <ul class="mt-results">
                    <li class="mt-result" ng-controller="mtSearchResultCtrl"
                        ng-repeat="i in ['D874kQpNEpc', 'eU4ZvfkmOck', 'djE-BLrdDDc', 'jb6HZa151s8', 'a35rNEBNiO4', 'URpIzQedQio', '_sV0QuxOHoY']">
                        <button class="mt-result__container" ng-click="addItemToQueue()">
                            <div class="mt-result__add-affordance"></div>

                            <div class="mt-result__thumbnail"
                                 ng-style="{'background-image': 'url(http://i1.ytimg.com/vi/{{i}}/mqdefault.jpg)'}">
                                <div class="mt-result__added-confirmation"
                                     ng-show="searchResultProps.showAddedConfirmation">
                                    <div class="text" mt-short-text="Video added to the queue">
                                        <span class="mt-replaced-text">Video added to the queue. 5 remaining tunes before yours to be played. Enjoy!</span>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-result__data">
                                <p class="title">Benard Menez - Ooh ooh ooh Jolie poupee</p>
                            </div>
                        </button>
                    </li>
                </ul>
            </div>
        </div>
    </div>
</div>
<script>
angular.module('app', ['ngAnimate', 'ngTouch']);

angular.module('app').config(function ($locationProvider) {
    $locationProvider.html5Mode(true);
});

angular.module('app').controller('mtSearchResultCtrl', function ($scope, $timeout) {

    $scope.searchResultProps = {showAddedConfirmation: false, tmoPromise: null};

    $scope.addItemToQueue = function () {
        $scope.searchResultProps.showAddedConfirmation = true;
        $timeout.cancel($scope.searchResultProps.tmoPromise);
        $scope.searchResultProps.tmoPromise = $timeout(function () {
            $scope.searchResultProps.showAddedConfirmation = false;
        }, 4000);
    }
});

angular.module('app').controller('mtBodyCtrl', function ($scope, $location) {

    var _props = {
        queueSize: 1,
        queueItemsSrc: ['D874kQpNEpc', 'eU4ZvfkmOck', 'djE-BLrdDDc', 'jb6HZa151s8', 'a35rNEBNiO4', 'URpIzQedQio', '_sV0QuxOHoY'],
        queueItems: []
    };

    $scope.props = {
        showDebugBar: false,
        showModal: false,
        showNotification: false,
        showSearch: false,
        get queueItems() {
            return _props.queueItems;
        }
    };

    $scope.toggleModal = function (lineCount) {
        var lines = [0, 1, 2, 3, 4, 5, 6, 7];
        $scope.props.modalLines = lines.slice(0, lineCount);
        $scope.props.showModal = !$scope.props.showModal;
    };

    $scope.toggleNotification = function () {
        $scope.props.showNotification = !$scope.props.showNotification;
    };

    $scope.toggleComingNext = function () {
        $scope.props.showComingNext = !$scope.props.showComingNext;
    };

    $scope.toggleSearch = function () {
        $scope.props.showSearch = !$scope.props.showSearch;
    };

    $scope.appendQueueItem = function () {
        _props.queueItems = _props.queueItemsSrc.slice(0, _props.queueSize++);
    };

    $scope.insertQueueItem = function () {
        _props.queueItems.splice(1, 0, _props.queueItemsSrc[_props.queueSize++]);
    };

    $scope.$watch(function () {
        return $location.search();
    }, function (newSearch) {
        $scope.props.showDebugBar = 'debug' in newSearch;
    });

    $scope.$watch('props.searchTerm', function (newVal) {
        $scope.props.showSearch = !!newVal;
    });
});

/**
 * @ngdoc directive
 * @name mt.directive:mtMouseInteractionDetection
 * @restrict A
 *
 * Adds the specified class to the element when a mouse based interaction is detected.
 *
 * The detection mechanism is inspired by https://github.com/stucox/Modernizr/blob/hover/feature-detects/device/hover.js
 * where we try to detect two consecutive "mousemove" events without an intervening "mousedown" event. This sequence
 * is not possible with a touch (only) interaction based device.
 */
angular.module('app').directive('mtMouseInteractionDetection', function () {
    return {
        restrict: 'A',
        link: function (iScope, iElement, iAttrs) {

            var className = iAttrs.mtMouseInteractionDetection;
            if (!className) throw new Error('mtMouseInteractionDetection require an attribute value');

            var mouseMoveCount = 0;

            function mouseDownHandler() {
                mouseMoveCount = 0;
            }

            iElement
                    .on('mousedown', mouseDownHandler)
                    .on('mousemove', function mouseMoveHandler() {
                        if (++mouseMoveCount > 1) {
                            iElement
                                    .off('mousedown', mouseDownHandler)
                                    .off('mousemove', mouseMoveHandler);
                            iElement.addClass(className);
                        }
                    });
        }
    };
});

/**
 * @ngdoc directive
 * @name mt.directive:mtSearchInput
 * @restrict A
 *
 * @description
 * A single usage directive that controls the sequencing of search input animation.
 *
 * Focus needs to be called inside a user initiated DOM event handler to show the virtual keyboard on mobile which
 * can't be guaranteed by AngularJS (because of the digestion loop).
 * On click on ".mt-search-input__button" we focus the real input first and then we start the animation of
 * ".mt-search-input". We are leveraging the regular ngHide animation so the required styles are the same.
 */
angular.module('app').directive('mtSearchInput', function ($animate) {

    /**
     * @const
     * @type {string}
     */
    var NG_ACTIVE_CLASS_NAME = 'ng-click-active';

    return {
        restrict: 'A',
        link: function (iScope, iElement) {

            var searchInputForm = angular.element(iElement[0].querySelector('.mt-js-search-input__form'));
            var trigger = angular.element(iElement[0].querySelector('.mt-js-search-input__button'));
            var inputElmt = searchInputForm[0].querySelector('.mt-js-search-input__field');

            var hide = true;

            function sync() {
                $animate[hide ? 'addClass' : 'removeClass'](searchInputForm, 'ng-hide');
                inputElmt[hide ? 'blur' : 'focus']();
            }

            // we need to blur the field on form submit to hide the virtual keyboard on mobile
            searchInputForm.on('submit', function () {
                inputElmt.blur();
            });

            // on mobile, focusing a field programatically only works from a click event handler dispatched directly by the browser
            trigger
                    .on('click', function () {
                        hide = !hide;
                        sync();
                    })
                // simulates ngTouch behavior for active class
                    .on('touchstart', function () {
                        trigger.addClass(NG_ACTIVE_CLASS_NAME);
                    })
                    .on('touchend touchmove touchcancel', function () {
                        trigger.removeClass(NG_ACTIVE_CLASS_NAME);
                    });

            // sync at first rendering
            sync();
        }
    }
});

angular.module('app').animation('.mt-js-queue__item__animation-repeat', function () {

    // basic animation tool
    var Sequence = {
        __stages: null,
        get _stages() {
            return this.__stages || (this.__stages = []);
        },

        then: function (css) {
            this._stages.push(css);
            return this;
        },

        run: function (element, done) {
            var sequence = this;
            window.requestAnimationFrame(function exec() {
                if (sequence._stages.length) {
                    element.css(sequence._stages.shift()).one('transitionend', function () {
                        exec();
                    });
                } else {
                    done();
                }
            });
        }
    };

    /**
     * The css "transform" property name for the current environment. Chrome (as of 31) is the only supported browser
     * that still needs prefixed transform property (webkit prefixed).
     *
     * @const
     * @type {string}
     */
    var TRANSFORM_PROP_NAME = typeof document.createElement('div').style['-webkit-transform'] !== 'undefined' ? '-webkit-transform' : 'transform';

    // reset css properties to default values
    var FINAL = {};
    FINAL['transition'] = '';
    FINAL['height'] = '';
    FINAL[TRANSFORM_PROP_NAME] = '';

    function transition(element, entering, heightFrom, heightTo, transformFrom, transformTo, done) {

        var transitionHeight = {};
        transitionHeight['transition-duration'] = '.175s';
        transitionHeight['transition-property'] = 'height';
        transitionHeight['height'] = heightTo + 'px';

        // then translate to put the item inside the view port
        var transitionTransform = {};
        transitionTransform['transition-duration'] = '.175s';
        transitionTransform['transition-property'] = TRANSFORM_PROP_NAME;
        transitionTransform[TRANSFORM_PROP_NAME] = transformTo;

        var initial = {};
        initial[TRANSFORM_PROP_NAME] = transformFrom;

        var sequence = Object.create(Sequence);

        var stages = [];
        // if the element is not at the end we need to animate the height
        if (element.next().length) {
            initial['height'] = heightFrom + 'px';
            stages.push(transitionHeight);
        }
        stages.push(transitionTransform);

        if (!entering) {
            stages.reverse();
        }

        stages.forEach(function (stage) {
            sequence.then(stage);
        });

        element.css(initial);
        sequence.run(element, done);
    }

    return {

        enter: function (element, done) {

            // we might get a comment node as well here so we need to filter only the element
            element = element.eq(0);

            var heightFrom = 0;
            // we get the height at after insertion with floating point precision
            var heightTo = element[0].getBoundingClientRect().height;

            var transformFrom = 'translateX(-100%)';
            var transformTo = '';

            transition(element, true, heightFrom, heightTo, transformFrom, transformTo, done);

            return function () {
                element.css(FINAL);
            }
        },

        leave: function (element, done) {

        },

        move: function (element, done) {

        }
    };
});
</script>

</body>
</html>